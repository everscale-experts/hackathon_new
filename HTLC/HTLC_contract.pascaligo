type storage is record [
  unused  : bool;
  date   : timestamp;
  sender : address;
  dest   : address;
  hash   : bytes;
  value  : tez;
]

type createLockWithCoinsParams is michelson_pair(bytes, "hash", address,"dest")
type openLockParams is michelson_pair(address, "dest", bytes,"seed_f");
type defaultParams is unit;

type parameter is 
| Default of defaultParams
| CreateLockWithCoins of createLockWithCoinsParams
| OpenLock          of openLockParams


type return is list(operation) * storage

const noOperations: list(operation) = nil;

function default (var s: storage): return is 
    block{
      skip
    }
     with(noOperations,s)

function createLockWithCoins (const hash1 : bytes; const dest1 : address; var s : storage): return is
    begin
    (*проверяем больши ли одного теза в контракте *)
    if Tezos.balance < 1tez
    then failwith("Error balance HTLC contract")
    else skip;
    (* проверка был ли замок раскрыт *)
    if not s.unused
    then failwith("This contract has already been used.")
    else skip;
    //const value1: tez = Tezos.balance;
    
    const commit : storage = record [
        unused = False;
        date = Tezos.now + 86_400; 
        sender = Tezos.sender;
        dest = dest1;
        hash = hash1; 
        value = Tezos.balance // - 0.1tez
        ];

end with ((nil : list(operation)), commit)



function openLock (const dest: address; const seed_f: bytes; var s: storage):return is 
    begin 
    if s.unused
    then failwith("The chest was already open")
    else skip;
    s.unused :=True;
    const owner : contract (unit) =
    case (Tezos.get_contract_opt (Tezos.sender): option(contract(unit))) of [
      Some (contract) -> contract
    | None -> (failwith ("Not a contract") : (contract(unit)))
    ];

    const receiver : contract (unit) =
    case (Tezos.get_contract_opt (dest): option(contract(unit))) of [
      Some (contract) -> contract
    | None -> (failwith ("Not a contract") : (contract(unit)))
    ];
    var operations: list(operation) := nil;
    (*Не просрочена ли транзакция*)
    if Tezos.now > s.date
    then {
        const op : operation = Tezos.transaction (unit, s.value, owner); // если просроченна возвращаем отправителю
        operations:= list [
      op 
    ];
    }
    else {
        if Crypto.sha256(seed_f) = s.hash
        then{
            const op : operation = Tezos.transaction (unit, s.value, receiver); // если все хорошо отправляем коины на указанный адрес
            operations:= list [
      op
    ];
        }
        else {
            const op : operation = Tezos.transaction (unit, s.value, owner); // если hash не правильный отправляем коины отправителю
            operations:= list [
       op
    ];
        }
    }

end with (operations, s)



function main(const p:parameter; var s:storage): return is 
case p of [
| Default(params) -> default(s)
| CreateLockWithCoins(params)-> createLockWithCoins(params.0,params.1,s)
| OpenLock(params)-> openLock(params.0,params.1, s)
]