

type data is record[
  counter : int;
  date   : timestamp;
  dest : address;
  hash   : bytes;
  value  : nat;
  id_tokens : nat;
]

type value_bool is record [
    value  : tez;
    
]


type chest is big_map(address, data)


(*объявляем тип storage*)
type storage is record [
    counter: int;
    chests : chest;

]
type token_id is nat;
type transfer_destination is
[@layout:comb]
record [
 to_ : address;
 token_id : token_id;
 amount : nat;
]

type transfer is
[@layout:comb]
record [
 from_ : address;
 txs : list(transfer_destination);
]


(*объявляем псевдонимы входящих параметров для каждой базовой функции*)
type p1 is michelson_pair(bytes, "hash", address,"dest")
type p2 is michelson_pair(nat, "amount_tokens",p1, "pair")
type createLockParams is michelson_pair(nat, "id_tokens", p2, "pair")
type openLockParams is michelson_pair(address, "dest", bytes,"secret");

(*псевдо-точки входа*)
type parameter is 
| CreateLock of createLockParams
| OpenLock          of openLockParams


(*тип возвращаемых данных*)
type return is list(operation) * storage


(*адресс контракта токенов *)
const tokenAddress : address = ("KT1VKyokYCeTidBzepRJrBVrQDJPq6RH8RYn":address);

// вызов метода контракта работает 
 const entry_point : contract (list(transfer)) =
    case (Tezos.get_entrypoint_opt ("%transfer", tokenAddress): option(contract(list(transfer)))) of [
      Some (contract) -> contract
    | None -> (failwith ("Not a contract") : (contract(list(transfer))))
    ];


function createLock (const id_tokens : nat;const amount_tokens: nat; const hash1 : bytes; const dest1 : address; var s : storage): return is
    begin  
    (*счеткик *)
    s.counter := s.counter + 1;
    (*проверяем больши ли одного теза в контракте *)
    if amount_tokens < 10000n
    then failwith("Error balance HTLC contract")
    else skip;
    
    const data : data = record[
        counter = s.counter;
        date = Tezos.now + 3_600; 
        dest = dest1; 
        hash = hash1;
        value = amount_tokens; //-1n;
        id_tokens = id_tokens;
         ];
     const updated_map: chest = Big_map.update(Tezos.sender, Some(data), s.chests);
     s := s with record [chests = updated_map]; 
     
end with ((nil : list(operation)), s)



function openLock (const dest: address; const secret: bytes; var s: storage):return is 
    begin 

    
    (*поиск нужного сундука*)
     var data : data := record[
        counter = 0;
        date = Tezos.now + 3_600; 
        dest = dest; 
        hash = Crypto.sha256(secret);
        value = 0n;
        id_tokens=0n;
         ];
    case Big_map.find_opt(Tezos.sender, s.chests) of[
    | Some (c) -> data := c
    | None -> failwith("You have not chest")
    ];
    (*После прочтения удаляем запись из big_map*)
    const updated_map : chest = Big_map.remove (Tezos.sender, s.chests);
    s := s with record [chests = updated_map]; 

    var operations: list(operation) := nil;
    
    var transfer_destination1 : transfer_destination := record[
        to_ = dest;
        token_id=data.id_tokens;
        amount= data.value;
    ];
    const transfer_receiver : transfer = record[
        from_ = Tezos.self_address;
        txs = list[transfer_destination1];
    ];

    var transfer_destination : transfer_destination := record[
        to_ = Tezos.sender;
        token_id=data.id_tokens;
        amount= data.value;
    ];
    const transfer_owner : transfer = record[
        from_ = Tezos.self_address;
        txs = list[transfer_destination];
    ];



    (*Не просрочена ли транзакция*)
    if Tezos.now > data.date
    then {
        operations := Tezos.transaction(list[transfer_owner], 0mutez,  entry_point) # operations;
    }
    else {
        if Crypto.sha256(secret) = data.hash
        then{
            operations := Tezos.transaction(list[transfer_receiver], 0mutez,  entry_point) # operations;
        }
        else {
            operations := Tezos.transaction(list[transfer_owner], 0mutez,  entry_point) # operations;
        }
    }

end with (operations, s)



function main(const p:parameter; var s:storage): return is 
case p of [
| CreateLock(params)-> createLock(params.0,params.1.0,params.1.1.0, params.1.1.1,s)
| OpenLock(params)-> openLock(params.0,params.1, s)
]