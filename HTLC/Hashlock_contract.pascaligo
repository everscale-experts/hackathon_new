type commit is record [
  date        : timestamp;
  salted_hash : bytes;
]

type commit_set is big_map(address, commit)

type storage is record [
  hashed  : bytes;
  unused  : bool;
  commits : commit_set
]

type reveal is record [
  hashable : bytes;
  message  : unit -> list(operation)
]

type parameter is
  Commit of bytes
| Reveal of reveal

type return is list(operation) * storage

(* We use hash-commit so that a baker can not steal *)

function commit (const p : bytes; var s: storage) : return is
  begin
    const commit : commit = record [date = Tezos.now + 86_400; salted_hash = p];
    const updated_map: commit_set = Big_map.update(Tezos.sender, Some(commit), s.commits);
    s := s with record [commits = updated_map];    
  end with ((nil : list(operation)), s)

function reveal (const p: reveal; var s: storage) : return is
  begin
    if not s.unused
    then failwith("This contract has already been used.")
    else skip;
    var commit : commit := record [date = (0: timestamp); salted_hash = ("": bytes)];
    case Big_map.find_opt(sender, s.commits) of
    | Some (c) -> commit := c
    | None -> failwith("You have not made a commitment to hash against yet.")
    end;
    if Tezos.now < commit.date
    then failwith("It has not been 24 hours since your commit yet.");
    else skip;
    const salted : bytes =
      Crypto.sha256(
        Bytes.concat(p.hashable, Bytes.pack(sender))
      );
    if salted =/= commit.salted_hash
    then failwith("This reveal does not match your commitment.")
    else skip;
    if s.hashed = Crypto.sha256(p.hashable)
    then s := s with record [unused = False]
    else failwith("Your commitment did not match the storage hash.");
  end with (p.message(unit), s)

function main (const p: parameter; const s: storage) : return is
  case p of
  | Commit (c) -> commit (c,s)
  | Reveal (r) -> reveal (r,s)
  end


(*__________________________________*)
(*Тот же код но с моими коментариями*)
type commit is record [
  date        : timestamp;
  salted_hash : bytes;
]

type commit_set is big_map(address, commit)

type storage is record [
  hashed  : bytes;
  unused  : bool;
  commits : commit_set
]

type reveal is record [
  hashable : bytes;
  message  : unit -> list(operation)
]

type parameter is
  Commit of bytes
| Reveal of reveal

type return is list(operation) * storage

(* We use hash-commit so that a baker can not steal *)

function commit (const p : bytes; var s: storage) : return is
  begin
    const commit : commit = record [date = Tezos.now + 86_400; salted_hash = p];
    const updated_map: commit_set = Big_map.update(Tezos.sender, Some(commit), s.commits);
    s := s with record [commits = updated_map];    
  end with ((nil : list(operation)), s)

function reveal (const p: reveal; var s: storage) : return is
  begin
  (* проверка был ли контракт использован  *)
    if not s.unused
    then failwith("This contract has already been used.")
    else skip;
    (*записываем в переменную commit время и байты который будем хэшировать*)
    var commit : commit := record [date = (0: timestamp); salted_hash = ("": bytes)];
    (*находим в bigmap значение текущего commits в storage*)
    case Big_map.find_opt(sender, s.commits) of
    (*??????? ввод в big map значение commits*)
    | Some (c) -> commit := c
    (*?????? в случае если нету commits*)
    | None -> failwith("You have not made a commitment to hash against yet.")
    end;
    (*Делаем проверку на то сколько времени пройшло спустя commits *)
    if Tezos.now < commit.date
    (*есть 24 часа на то чтобы расхэшировать то что было захешированно*)
    then failwith("It has not been 24 hours since your commit yet.");
    else skip;
    (*присваем salted хэш ????? *)
    const salted : bytes =
      Crypto.sha256(
          (*объединяем байтовые строки*)
        Bytes.concat(p.hashable, Bytes.pack(sender))
      );
      (*если salted не равен байтовой строке которая лежит в commits, то ошибка *)
    if salted =/= commit.salted_hash
    then failwith("This reveal does not match your commitment.")
    else skip;
    (*если байты лежащие в storage равны байтам которые получаются в результате хэширования байтов которые мы передали в функ reveal *)
    if s.hashed = Crypto.sha256(p.hashable)
    (* в storage обновляем значение unused*)
    then s := s with record [unused = False]
    (*если не так то выводим ошибку*)
    else failwith("Your commitment did not match the storage hash.");
    (*в конце ???????*)
  end with (p.message(unit), s)
(*объявляем точки входа*)
function main (const p: parameter; const s: storage) : return is
  case p of
  | Commit (c) -> commit (c,s)
  | Reveal (r) -> reveal (r,s)
  end
