type commit is record [
  date        : timestamp;
  salted_hash : bytes;
]

type commit_set is big_map(address, commit)

type storage is record [
  hashed  : bytes;
  unused  : bool;
  commits : commit_set
]

type reveal is record [
  hashable : bytes;
  message  : unit -> list(operation)
]

type parameter is
  Commit of bytes
| Reveal of reveal

type return is list(operation) * storage

(* We use hash-commit so that a baker can not steal *)

function commit (const p : bytes; var s: storage) : return is
  begin
    const commit : commit = record [date = Tezos.now + 86_400; salted_hash = p];
    const updated_map: commit_set = Big_map.update(Tezos.sender, Some(commit), s.commits);
    s := s with record [commits = updated_map];    
  end with ((nil : list(operation)), s)

function reveal (const p: reveal; var s: storage) : return is
  begin
    if not s.unused
    then failwith("This contract has already been used.")
    else skip;
    var commit : commit := record [date = (0: timestamp); salted_hash = ("": bytes)];
    case Big_map.find_opt(sender, s.commits) of
    | Some (c) -> commit := c
    | None -> failwith("You have not made a commitment to hash against yet.")
    end;
    if Tezos.now < commit.date
    then failwith("It has not been 24 hours since your commit yet.");
    else skip;
    const salted : bytes =
      Crypto.sha256(
        Bytes.concat(p.hashable, Bytes.pack(sender))
      );
    if salted =/= commit.salted_hash
    then failwith("This reveal does not match your commitment.")
    else skip;
    if s.hashed = Crypto.sha256(p.hashable)
    then s := s with record [unused = False]
    else failwith("Your commitment did not match the storage hash.");
  end with (p.message(unit), s)

function main (const p: parameter; const s: storage) : return is
  case p of
  | Commit (c) -> commit (c,s)
  | Reveal (r) -> reveal (r,s)
  end


(*__________________________________*)
(*Тот же код но с моими коментариями*)
type commit is record [
  date        : timestamp;
  salted_hash : bytes;
]

type commit_set is big_map(address, commit)

type storage is record [
  hashed  : bytes;
  unused  : bool;
  commits : commit_set
]

type reveal is record [
  hashable : bytes;
  message  : unit -> list(operation)
]

type parameter is
  Commit of bytes
| Reveal of reveal

type return is list(operation) * storage

(* We use hash-commit so that a baker can not steal *)

function commit (const p : bytes; var s: storage) : return is
  begin
    const commit : commit = record [date = Tezos.now + 86_400; salted_hash = p];
    const updated_map: commit_set = Big_map.update(Tezos.sender, Some(commit), s.commits);
    s := s with record [commits = updated_map];    
  end with ((nil : list(operation)), s)

function reveal (const p: reveal; var s: storage) : return is
  begin
  (* проверка был ли контракт использован  *)
    if not s.unused
    then failwith("This contract has already been used.")
    else skip;
    (*записываем в переменную commit время и байты который будем хэшировать*)
    var commit : commit := record [date = (0: timestamp); salted_hash = ("": bytes)];
    (*находим в bigmap значение текущего commits в storage*)
    case Big_map.find_opt(sender, s.commits) of
    (*??????? ввод в big map значение commits*)
    | Some (c) -> commit := c
    (*?????? в случае если нету commits*)
    | None -> failwith("You have not made a commitment to hash against yet.")
    end;
    (*Делаем проверку на то сколько времени пройшло спустя commits *)
    if Tezos.now < commit.date
    (*есть 24 часа на то чтобы расхэшировать то что было захешированно*)
    then failwith("It has not been 24 hours since your commit yet.");
    else skip;
    (*присваем salted хэш ????? *)
    const salted : bytes =
      Crypto.sha256(
          (*объединяем байтовые строки*)
        Bytes.concat(p.hashable, Bytes.pack(sender))
      );
      (*если salted не равен байтовой строке которая лежит в commits, то ошибка *)
    if salted =/= commit.salted_hash
    then failwith("This reveal does not match your commitment.")
    else skip;
    (*если байты лежащие в storage равны байтам которые получаются в результате хэширования байтов которые мы передали в функ reveal *)
    if s.hashed = Crypto.sha256(p.hashable)
    (* в storage обновляем значение unused*)
    then s := s with record [unused = False]
    (*если не так то выводим ошибку*)
    else failwith("Your commitment did not match the storage hash.");
    (*в конце ???????*)
  end with (p.message(unit), s)
(*объявляем точки входа*)
function main (const p: parameter; const s: storage) : return is
  case p of
  | Commit (c) -> commit (c,s)
  | Reveal (r) -> reveal (r,s)
  end



(*HTLC контракт который начал писать я*)
 (*___________________________________________*)

type commit is record [
  date   : timestamp;
  sender : address;
  dest   : address;
  hash   : bytes;
  value  : tez;
]


type commit_set is big_map(string,commit)

type storage is record [
  hashed  : bytes;
  unused  : bool;
  commits : commit_set
]

type return is list(operation) * storage

function createLockWithCoins (const hash1 : bytes; const dest1 : address; var s : storage): return is
    begin
    (*проверяем больши ли одного теза в контракте *)
    if Tezos.balance < 1tez
    then failwith("Error balance HTLC contract")
    else skip;
    (* проверка был ли замок раскрыт *)
    if not s.unused
    then failwith("This contract has already been used.")
    else skip;
    const commit : commit = record [
        date = Tezos.now + 86_400; 
        sender = Tezos.sender; 
        dest = dest1; 
        hash = hash1; 
        value = Tezos.balance - 0.1tez 
        ];
    const updated_map: commit_set = Big_map.update(Tezos.sender, Some(commit), s.commits);
    s := s with record [commits = updated_map];
end with ((nil : list(operation)), s)



// function OpenLock (const dest: address; const seed_f: bytes; var s: storage):return is 
//     begin 
//     (*Не просрочена ли транзакция*)
//     if Tezos.now < commit.date
//     then Tezos.transaction();
//     else skip;
    
//     if Crypto.sha256(seed_f)
//     then Tezos.transaction()





(*_____________________________________*)
(*третий вариант*)




type storage is record [
  unused  : bool;
  date   : timestamp;
  sender : address;
  dest   : address;
  hash   : bytes;
  value  : tez;
]

type createLockWithCoinsParams is michelson_pair(bytes, "hash", address,"dest")

type openLockParams is michelson_pair(address, "dest", bytes,"seed_f");

type parameter is 
| CreateLockWithCoins of createLockWithCoinsParams
| OpenLock          of openLockParams

type return is list(operation) * storage

function createLockWithCoins (const hash1 : bytes; const dest1 : address; var s : storage): return is
    begin
    (*проверяем больши ли одного теза в контракте *)
    if Tezos.balance < 1tez
    then failwith("Error balance HTLC contract")
    else skip;
    (* проверка был ли замок раскрыт *)
    if not s.unused
    then failwith("This contract has already been used.")
    else skip;
    
    
    const commit : storage = record [
        unused = False;
        date = Tezos.now + 86_400; 
        sender = Tezos.sender;
        dest = dest1;
        hash = hash1; 
        value = Tezos.balance - 0.1tez
        ];

end with ((nil : list(operation)), commit)



function openLock (const dest: address; const seed_f: bytes; var s: storage):return is 
    begin 
    
    const owner : contract (unit) =
    case (Tezos.get_contract_opt (Tezos.sender): option(contract(unit))) of [
      Some (contract) -> contract
    | None -> (failwith ("Not a contract") : (contract(unit)))
    ];

    const reciver : contract (unit) =
    case (Tezos.get_contract_opt (dest): option(contract(unit))) of [
      Some (contract) -> contract
    | None -> (failwith ("Not a contract") : (contract(unit)))
    ];
    (*Не просрочена ли транзакция*)
    if Tezos.now < s.date
    then {
        const _op : operation = Tezos.transaction (unit, s.value, owner); // если просроченна возвращаем отправителю
    }
    else {
        if Crypto.sha256(seed_f) = s.hash
        then{
            const _op : operation = Tezos.transaction (unit, s.value, reciver); // если все хорошо отправляем коины на указанный адрес
        }
        else {
            const _op : operation = Tezos.transaction (unit, s.value, owner); // если hash не правильный отправляем коины отправителю
        }
    }

end with ((nil: list(operation)), s)



function main(const p:parameter; var s:storage): return is 
case p of [
| CreateLockWithCoins(params)-> createLockWithCoins(params.0,params.1,s)
| OpenLock(params)-> openLock(params.0,params.1, s)
]
